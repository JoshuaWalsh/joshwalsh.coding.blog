<!DOCTYPE html><html><head><title>Coding Blog Boilerplate | Making an animated Hilbert Curve using WebGL</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><meta name="robots" content="index,follow"><meta name="theme-color" content="#212121"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link rel="shortcut icon" href="/coding-blog-boilerplate/favicon.ico"><link href="https://fonts.googleapis.com/css?family=Hind:400,700&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:300,400&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/icon?family=Material+Icons%7CMaterial+Icons+Outlined&amp;display=swap" rel="stylesheet"><style>
      body, input, button {
        font-family: 'Hind', sans-serif;
      }

      code, .hljs {
        font-family: 'Source Code Pro', 'Courier New', Courier, monospace;
      }

      .icon-font {
        font-family: 'Material Icons';
        font-weight: normal;
        font-style: normal;
        font-size: 24px;  /* Preferred icon size */
        display: inline-block;
        line-height: 1;
        text-transform: none;
        letter-spacing: normal;
        word-wrap: normal;
        white-space: nowrap;
        direction: ltr;
      
        /* Support for all WebKit browsers. */
        -webkit-font-smoothing: antialiased;
        /* Support for Safari and Chrome. */
        text-rendering: optimizeLegibility;
      
        /* Support for Firefox. */
        -moz-osx-font-smoothing: grayscale;
      
        /* Support for IE. */
        font-feature-settings: 'liga';
      }

      .icon-font.outline {
        font-family: 'Material Icons Outlined';
      }
    </style><link href="/coding-blog-boilerplate/styles/codedoc-styles.css" rel="stylesheet"><script async="" defer="" src="/coding-blog-boilerplate/bundle/codedoc-bundle.js"></script><script>window.githubConfig={"repo":"coding-blog-boilerplate","user":"CONNECT-platform"}</script><style>.container{padding-top: 0 !important}</style><style>#-codedoc-toc { backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px) }</style><meta name="twitter:title" content="Coding Blog Boilerplate | Making an animated Hilbert Curve using WebGL"><meta property="og:type" content="article"><meta property="og:title" content="Coding Blog Boilerplate | Making an animated Hilbert Curve using WebGL"><meta name="keywords" content=""><meta property="blog-tags" content=""></head><body><div class="header-0-0-4"><a class="watermark-0-0-3" href="https://coding.blog" target="_blank"><svg viewBox="0 0 701 443" version="1.1" xmlns="http://www.w3.org/2000/svg"><g id="coding.blog" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g transform="translate(-162.000000, -246.000000)" id="Shape"><path d="M538.081948,246.348452 L538.52402,246.445719 L538.52402,246.445719 L538.85529,246.526578 L538.85529,246.526578 L600.956012,263.165455 C602.767076,263.660918 604.526214,264.465865 606.146589,265.591976 C611.80881,269.527048 614.090389,276.211909 612.345003,282.123825 L538.2641,559.728905 C537.816127,561.562539 536.989561,563.335054 535.765607,564.944016 C530.70443,571.597248 520.764856,572.934442 513.564947,567.930724 C507.902727,563.995652 505.621148,557.310791 507.366534,551.398875 L577.145082,289.91439 L546.233523,281.631663 L462.305576,595.917544 L468.439004,634.645619 L493.907962,603.194573 C499.468987,596.327279 509.54413,595.268339 516.411424,600.829364 C523.278717,606.390389 524.337658,616.465532 518.776633,623.332826 L470.948283,682.395919 C466.887248,687.410879 460.418878,689.3283 454.55045,687.832105 L454.212574,687.741996 C448.224449,686.200133 443.421088,681.240355 442.392221,674.744345 L430.503202,599.680031 C430.418831,599.147339 430.361793,598.616628 430.331048,598.089327 C429.783912,595.705405 429.838457,593.220092 430.535776,590.858154 L519.361965,258.223717 L519.447729,257.889555 L519.447729,257.889555 L519.532157,257.586199 L519.627058,257.23399 C520.074771,255.398716 520.901697,253.624577 522.126677,252.014264 C525.828762,247.147643 532.141006,245.125338 538.081948,246.348452 Z M632.156421,656.157784 C640.992977,656.157784 648.156421,663.321228 648.156421,672.157784 C648.156421,680.99434 640.992977,688.157784 632.156421,688.157784 L528.156421,688.157784 C519.319865,688.157784 512.156421,680.99434 512.156421,672.157784 C512.156421,663.321228 519.319865,656.157784 528.156421,656.157784 L632.156421,656.157784 Z M699.234631,342.452157 L857.62655,500.844076 C863.874939,507.092464 863.874939,517.223104 857.62655,523.471493 L699.234631,681.863412 C692.986243,688.1118 682.855603,688.1118 676.607214,681.863412 C670.358826,675.615023 670.358826,665.484383 676.607214,659.235995 L823.686132,512.157077 L676.607214,365.079574 C670.358826,358.831185 670.358826,348.700545 676.607214,342.452157 C682.855603,336.203768 692.986243,336.203768 699.234631,342.452157 Z M347.705627,342.452157 C353.954016,348.700545 353.954016,358.831185 347.705627,365.079574 L200.62671,512.158491 L347.705627,659.235995 C353.954016,665.484383 353.954016,675.615023 347.705627,681.863412 C341.457239,688.1118 331.326599,688.1118 325.07821,681.863412 L166.686292,523.471493 C160.437903,517.223104 160.437903,507.092464 166.686292,500.844076 L325.07821,342.452157 C331.326599,336.203768 341.457239,336.203768 347.705627,342.452157 Z"></path></g></g></svg></a></div><div id="-codedoc-container" class="container"><script>window.source = {"base":"posts","path":"hilbert-shader.md","namespace":"/coding-blog-boilerplate","title":{"base":"Coding Blog Boilerplate","connector":" | "}}</script><div class="hero-0-0-10" style="margin-bottom: -96px"><img src="/coding-blog-boilerplate/img/hilbert-curve.jpg" class="image-0-0-11" data-hero=""><span class="caption-0-0-12"></span></div><h1 class="h-0-0-13 white"><span style=" 
      text-shadow: 0 0 8px black; 
      font-size: 48px"><p>Making an animated Hilbert Curve using WebGL</p></span></h1><script id="IHxKFWTnzD">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("IHxKFWTnzD", "uU5Mf6hX80XLVyK7wxWrHg==", {"src":"github"});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><marker><br>

</marker><p>This blog post details the process of creating my <a href="https://sandbox.ymindustries.com/pixelshader/hilbert.html">animated Hilbert Curve WebGL toy</a>.</p><p><em>Note: For some reason the toy doesn't work on some mobile devices. I'm not yet sure why, I still need to look into it.</em></p><p><em><strong>SYNDICATED CONTENT:</strong> This post originally appeared on blog.joshwalsh.me. You can find the original <a href="https://blog.joshwalsh.me/hilbert-shader/">here</a>. Some formatting and content has been removed in order to fit the <code>coding.blog</code> platform.</em></p><hr><h1 id="inspiration" class="heading-0-0-14"><span class="anchor-0-0-15" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Inspiration</h1><p>I’ve been growing increasingly interested in shaders. I think I’ve created some nice looking visual effects using only the CPU, but performance has always been a key limitation. This was probably most evident when creating my <a href="https://sandbox.ymindustries.com/clouds">Moonlit Clouds</a> toy. My original idea for how to fake volumetric lighting ended up very slow in Firefox Quantum, and completely non-functional in any other browser. Luckily I accidentally discovered a much cheaper method which looks almost as good. I knew I wanted to learn to use WebGL, I just needed an idea that would provide me with sufficient motivation to do so.</p><p>On 2018-04-21 I read <a href="https://blog.benjojo.co.uk/post/scan-ping-the-internet-hilbert-curve">a blog post</a> about using Hilbert Curves to map the internet in a way that humans could visually understand. Within the post there’s an animation of a small section of the internet which was moving through the Hilbert Curve. As soon as I saw this I wondered what it would look like if a much bigger Hilbert Curve was animated. Given that a large number of pixels would have to be updated every single frame, this seemed like the perfect opportunity to try out WebGL.</p><h1 id="research" class="heading-0-0-14"><span class="anchor-0-0-15" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Research</h1><p>I didn’t want to spoil the challenge for myself, so my research into this was pretty much entirely comprised of reading the Wikipedia article about Hilbert Curves. Fortunately the wikipedia article includes some sample code for transforming points in Cartesian Space into Hilbert Space, and vice-versa. Pixel Shaders work by running a piece of code against every single pixel that needs to be rendered, all in parallel. This means it’s important that we can find the distance along the Hilbert Curve that any pixel is, given only its coordinates.</p><p>The other piece of research I did was into WebGL itself. I tried a few tutorials, but was frustrated by something they all had in common: you needed to copy/paste large quantities of unexplained boilerplate code before you could get the simplest program working. I eventually cut out the middleman and simply downloaded a <a href="https://github.com/paulirish/webgl-boilerplate">boilerplate</a>, abandoning any tutorials.</p><h1 id="first-steps" class="heading-0-0-14"><span class="anchor-0-0-15" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>First steps</h1><p>The boilerplate I used came with a <a href="https://sandbox.ymindustries.com/pixelshader/example.html">lovely sample shader</a> to show that it was working, but I wanted to make my own simple shader program just to get used to it. I decided that a good Hello World program would be to just display a random colour for every pixel. The challenge I encountered with this is that WebGL doesn’t include any PRNG (Psueo-Random Number Generator) functions.</p><p>After a quick Google search I found a one-liner GLSL PRNG which is compatible with WebGL. I got it from <a href="https://stackoverflow.com/a/4275343/674675">here</a> but it seems that the snippet is so ubiquitous that its exact origins are unknown. It’s not a particularly good PRNG (for reasons mentioned in <a href="http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/">this blog post</a>) but it’s easy and good enough for my Hello World program.</p><p>You can see my noise shader <a href="https://sandbox.ymindustries.com/pixelshader/noise.html">here</a>.</p><h1 id="porting-the-hilbert-curve-algorithm" class="heading-0-0-14"><span class="anchor-0-0-15" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Porting the Hilbert Curve algorithm</h1><p>With my first shader done, I got to work on my real project. Before I could do anything else, like experimenting with animations and colours, I had to get the Hilbert Curve algorithm working within a shader. I copy/pasted the algorithm from Wikipedia, then quickly modified it to use valid GLSL syntax.</p><p>Most of these changes were simple. For example, WebGL1 (which I was using) doesn’t have a modulo/remainder operator (%), so any uses of that had to be converted to use the mod() function instead. One of the changes was a bit harder though...</p><h1 id="bitwise-functions" class="heading-0-0-14"><span class="anchor-0-0-15" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Bitwise functions</h1><p>The example code from Wikipedia made use of a few bitwise operators. Bitwise operators aren’t supported in WebGL1. Researching this limitation, I found a <a href="https://gist.github.com/EliCDavis/f35a9e4afb8e1c9ae94cce8f3c2c9b9a">gist</a> with some examples of functions to achieve bitwise behaviour in WebGL1. This worked well for AND, but sadly didn’t include XOR or even NOT, so I would have to build these myself.</p><p>To do this, I first looked into how the bitwise imitation functions worked. The gist doesn’t explain it, but fortunately the method is quite simple. There are a few components to how it works:</p><ol><li>Getting the value of a bit: Without bitwise operators, GLSL doesn’t give us a good way to get the value of a bit. The function instead uses division and modulo in order to achieve this.</li><li>Comparing isolated bits using boolean operators.</li><li>Setting the output bits: The function uses multiplication and addition to achieve this.</li><li>Iterating over all bits in the number and performing these operations.</li></ol><p>Once I understood this, it was straightforward to copy one of the functions and adapt it into a NOT function. Once I had my NOT function, I could create an XOR function by combining the other bitwise functions.</p><p>After implementing that naive solution, I realised that for unsigned integers, all a bitwise NOT does is subtract the integer from INT_MAX. INT_MAX in this case is $2^{32} - 1$, or $4,294,967,295$. Replacing my iterative NOT function with a simple subtraction didn’t noticeably change anything, but doubtless it improved performance by some degree.</p><p>But this got me thinking, what were my bitwise functions really doing?</p><h1 id="replacing-bitwise-functions" class="heading-0-0-14"><span class="anchor-0-0-15" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Replacing bitwise functions</h1><p>Examining the code from Wikipedia, we can see that the xy2d function uses two bitwise operators. The first is the bitwise AND, which is used here:</p><pre class=""><code class="c -codedoc-code-snippet code-0-0-16" tabindex="0"><span class="wmbar-0-0-19"><span></span><span></span><span></span><span></span></span><div class="line-0-0-18  -codedoc-code-line" data-content="rx = (x &amp; s) > 0;" id="code1-l1"><span class="lineCounter-0-0-17 prim -codedoc-line-counter">1<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>rx <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span></div><br><div class="line-0-0-18  -codedoc-code-line" data-content="ry = (y &amp; s) > 0;" id="code1-l2"><span class="lineCounter-0-0-17 prim -codedoc-line-counter">2<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>ry <span class="token operator">=</span> <span class="token punctuation">(</span>y <span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span></div><br></code></pre><p>The <code>x</code> and <code>y</code> variables contain the coordinates of the current pixel. The value <code>s</code> is always a power of two. Because it’s always a power of two, this means the bitwise AND will only ever return 1 bit worth of data, the bit that represents a value of <code>s</code>. We can achieve the same thing using the modulo function:</p><pre class=""><code class="c -codedoc-code-snippet code-0-0-16" tabindex="0"><span class="wmbar-0-0-19"><span></span><span></span><span></span><span></span></span><div class="line-0-0-18  -codedoc-code-line" data-content="rx =x % s*2 >= s; " id="code2-l1"><span class="lineCounter-0-0-17 prim -codedoc-line-counter">1<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>rx <span class="token operator">=</span>x <span class="token operator">%</span> s<span class="token operator">*</span><span class="token number">2</span> <span class="token operator">&gt;=</span> s<span class="token punctuation">;</span> </div><br><div class="line-0-0-18  -codedoc-code-line" data-content="ry = y % s*2 >= s;" id="code2-l2"><span class="lineCounter-0-0-17 prim -codedoc-line-counter">2<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>ry <span class="token operator">=</span> y <span class="token operator">%</span> s<span class="token operator">*</span><span class="token number">2</span> <span class="token operator">&gt;=</span> s<span class="token punctuation">;</span></div><br></code></pre><p>The second bitwise operator is XOR, which is used here:</p><pre class=""><code class="c -codedoc-code-snippet code-0-0-16" tabindex="0"><span class="wmbar-0-0-19"><span></span><span></span><span></span><span></span></span><div class="line-0-0-18  -codedoc-code-line" data-content="d += s * s * ((3 * rx) ^ ry);" id="code3-l1"><span class="lineCounter-0-0-17 prim -codedoc-line-counter">1<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>d <span class="token operator">+=</span> s <span class="token operator">*</span> s <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> rx<span class="token punctuation">)</span> <span class="token operator">^</span> ry<span class="token punctuation">)</span><span class="token punctuation">;</span></div><br></code></pre><p>This one appears complicated at first, but it makes more sense when you consider that <code>rx</code> and <code>ry</code> will only ever have a value of <code>0</code> or <code>1</code>. Given that there are only four possible combinations of this values, I decided to understand them using a truth table:</p><table><thead><th style="text-align: left">rx</th><th style="text-align: left">ry</th><th style="text-align: left">output</th></thead><tbody><tr><td style="text-align: left">0</td><td style="text-align: left">0</td><td style="text-align: left">0</td></tr><tr><td style="text-align: left">0</td><td style="text-align: left">1</td><td style="text-align: left">1</td></tr><tr><td style="text-align: left">1</td><td style="text-align: left">0</td><td style="text-align: left">3</td></tr><tr><td style="text-align: left">1</td><td style="text-align: left">1</td><td style="text-align: left">2</td></tr></tbody></table><p>I ended up just replacing this with if statements:</p><pre class=""><code class="glsl -codedoc-code-snippet code-0-0-16" tabindex="0"><span class="wmbar-0-0-19"><span></span><span></span><span></span><span></span></span><div class="line-0-0-18  -codedoc-code-line" data-content="int f;" id="code4-l1"><span class="lineCounter-0-0-17 prim -codedoc-line-counter">1<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span><span class="token keyword">int</span> f<span class="token punctuation">;</span></div><br><div class="line-0-0-18  -codedoc-code-line" data-content="if(rx) { " id="code4-l2"><span class="lineCounter-0-0-17 -codedoc-line-counter">2<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span><span class="token keyword">if</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span> <span class="token punctuation">{</span> </div><br><div class="line-0-0-18  -codedoc-code-line" data-content="    if(ry) { " id="code4-l3"><span class="lineCounter-0-0-17 -codedoc-line-counter">3<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ry<span class="token punctuation">)</span> <span class="token punctuation">{</span> </div><br><div class="line-0-0-18  -codedoc-code-line" data-content="        f = 2; " id="code4-l4"><span class="lineCounter-0-0-17 -codedoc-line-counter">4<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>        f <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> </div><br><div class="line-0-0-18  -codedoc-code-line" data-content="    } else { " id="code4-l5"><span class="lineCounter-0-0-17 prim -codedoc-line-counter">5<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> </div><br><div class="line-0-0-18  -codedoc-code-line" data-content="        f = 3; " id="code4-l6"><span class="lineCounter-0-0-17 -codedoc-line-counter">6<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>        f <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> </div><br><div class="line-0-0-18  -codedoc-code-line" data-content="    } " id="code4-l7"><span class="lineCounter-0-0-17 -codedoc-line-counter">7<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    <span class="token punctuation">}</span> </div><br><div class="line-0-0-18  -codedoc-code-line" data-content="} else { " id="code4-l8"><span class="lineCounter-0-0-17 -codedoc-line-counter">8<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> </div><br><div class="line-0-0-18  -codedoc-code-line" data-content="    if(ry) { " id="code4-l9"><span class="lineCounter-0-0-17 -codedoc-line-counter">9<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ry<span class="token punctuation">)</span> <span class="token punctuation">{</span> </div><br><div class="line-0-0-18  -codedoc-code-line" data-content="        f = 1; " id="code4-l10"><span class="lineCounter-0-0-17 prim -codedoc-line-counter">10<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>        f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> </div><br><div class="line-0-0-18  -codedoc-code-line" data-content="    } else {" id="code4-l11"><span class="lineCounter-0-0-17 -codedoc-line-counter">11<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></div><br><div class="line-0-0-18  -codedoc-code-line" data-content="        f = 0; " id="code4-l12"><span class="lineCounter-0-0-17 -codedoc-line-counter">12<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>        f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </div><br><div class="line-0-0-18  -codedoc-code-line" data-content="    } " id="code4-l13"><span class="lineCounter-0-0-17 -codedoc-line-counter">13<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>    <span class="token punctuation">}</span> </div><br><div class="line-0-0-18  -codedoc-code-line" data-content="} " id="code4-l14"><span class="lineCounter-0-0-17 -codedoc-line-counter">14<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span><span class="token punctuation">}</span> </div><br><div class="line-0-0-18  -codedoc-code-line" data-content="d = d + (s * s * f);" id="code4-l15"><span class="lineCounter-0-0-17 prim -codedoc-line-counter">15<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span>d <span class="token operator">=</span> d <span class="token operator">+</span> <span class="token punctuation">(</span>s <span class="token operator">*</span> s <span class="token operator">*</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span></div><br></code></pre><p>Not very elegant, but it works. Technically conditionals (and branching) are bad for performance in shaders, but it’s fast enough for my purposes.</p><p>And with that, the Hilbert Curve works. From here it was a simple matter of experimenting with colouring schemes and animation speeds until I found something that looked good to me.</p><hr><marker><br>

</marker><script id="lhgKdpHFDv">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("lhgKdpHFDv", "uU5Mf6hX80XLVyK7wxWrHg==", {"src":"github"});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><script id="fynTQDJPTz">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("fynTQDJPTz", "Np8WqrudlIn6YtII/bgUUQ==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="contentnav-0-0-9" data-no-search=""><a href="#inspiration" class="h1" data-content-highlight="inspiration">Inspiration</a><a href="#research" class="h1" data-content-highlight="research">Research</a><a href="#first-steps" class="h1" data-content-highlight="first-steps">First steps</a><a href="#porting-the-hilbert-curve-algorithm" class="h1" data-content-highlight="porting-the-hilbert-curve-algorithm">Porting the Hilbert Curve algorithm</a><a href="#bitwise-functions" class="h1" data-content-highlight="bitwise-functions">Bitwise functions</a><a href="#replacing-bitwise-functions" class="h1" data-content-highlight="replacing-bitwise-functions">Replacing bitwise functions</a></div></div><div id="-codedoc-toc" class="toc-0-0-6"><div class="content-0-0-7"><p><a href="/coding-blog-boilerplate/">Home</a>
<a href="/coding-blog-boilerplate/hilbert-shader">Making an animated Hilbert Curve using WebGL</a>
<a href="/coding-blog-boilerplate/lyrics-1">Playing .lrc files in the browser</a>
<a href="/coding-blog-boilerplate/lyrics-2">One-day build: Themed animated lyrics webapp</a></p><p><br><br></p></div></div><div class="footer-0-0-5"><div class="left"><script id="CbgnrHdjLC">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("CbgnrHdjLC", "Y37hGkTcTeOjIepkBSGIQg==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div><div class="main"><div class="inside"></div></div><div class="right"><script id="moASsZWeAl">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("moASsZWeAl", "++96ku066si1YE+LPC+GGg==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div></div><script id="GmaxgfYjw_">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("GmaxgfYjw_", "YgUrfhgMTRkMOyJXSzrnNg==", {"namespace":"/coding-blog-boilerplate"});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></body></html>